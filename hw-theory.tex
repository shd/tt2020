\documentclass[10pt,a4paper,oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{stmaryrd}
\usepackage{cmll}
\usepackage{mathrsfs}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{proof}
\usepackage{tikz}
\usepackage{multicol}

\makeatletter
\newcommand{\dotminus}{\mathbin{\text{\@dotminus}}}

\newcommand{\@dotminus}{%
  \ooalign{\hidewidth\raise1ex\hbox{.}\hidewidth\cr$\m@th-$\cr}%
}
\makeatother

\usetikzlibrary{arrows,backgrounds,patterns,matrix,shapes,fit,calc,shadows,plotmarks}

\newtheorem{definition}{Определение}
\begin{document}

\begin{center}{\Large\textsc{\textbf{Теоретические (``малые'') домашние задания}}}\\
             \it Теория типов, ИТМО, М3235-М3239, весна 2020 года\end{center}

\section*{Домашнее задание №1: <<вводная лекция для ТТ и ФП>>}

\begin{enumerate}

\item Напомним определения с лекций:

\begin{tabular}{lll}
Обозначение & лямбда-терм & название\\\hline
$T$ & $\lambda a.\lambda b.a$ & истина\\
$F$ & $\lambda a.\lambda b.b$ & ложь\\
$Not$ & $\lambda x.x\ F\ T$ & отрицание\\
$And$ & $\lambda x.\lambda y.x\ y\ F$ & конъюнкция
\end{tabular}

Проредуцируйте следующие выражения и найдите нормальную форму:

\begin{enumerate}
\item $T\ F$
\item $(T\ Not\ (\lambda t.t))\ F$
\item $And\ F\ T$
\item $And\ T\ T$
\end{enumerate}

\item Постройте лямбда-выражения для следующих булевских выражений:
\begin{enumerate}
\item Дизъюнкция
\item Штрих Шеффера (<<и-не>>)
\item Исключающее или
\end{enumerate}

\item Напомним определения с лекций:

$$f^{(n)}\ X ::= \left\{\begin{array}{ll} X, & n=0\\
                                f^{(n-1)}\ (f\ X), & n>0\end{array}\right.$$

\begin{center}\begin{tabular}{lll}
Обозначение & лямбда-терм & название\\\hline
$\overline{n}$ & $\lambda f.\lambda x.f^{(n)}\ x$ & чёрчевский нумерал\\
$(+1)$ & $\lambda n.\lambda f.\lambda x.n\ f\ (f\ x)$ & прибавление 1\\
$IsZero$ & $\lambda n.n\ (\lambda x.F)\ T$ & проверка на 0
\end{tabular}\end{center}

Используя данные определения, постройте выражения для следующих операций над числами:

\begin{enumerate}
\item Сложение
\item Умножение на 2 ($Mul2$)
\item Умножение
\item Возведение в степень
\item Проверка на чётность
\item Деление на 3 (могут потребоваться пары и/или вычитания)
\item Сравнение двух чисел ($IsLess$) — истина, если первый аргумент меньше второго
(могут потребоваться пары и/или вычитания)
\end{enumerate}

\item Проредуцируйте выражение и найдите его нормальную форму: 
\begin{enumerate}
\item $\overline{2}\ \overline{2}$
\item $\overline{2}\ \overline{2}\ \overline{2}$
\item $\overline{2}\ \overline{2}\ \overline{2}\ \overline{2}\ \overline{2}\ \overline{2}\ \overline{2}$
\end{enumerate}

\item Напомним определения с лекций:

\begin{tabular}{lll}
Обозначение & лямбда-терм & название\\\hline
$MkPair$ & $\lambda a.\lambda b.(\lambda x.x\ a\ b)$ & создание пары\\
$PrL$ & $\lambda p.p\ T$ & левая проекция\\
$PrR$ & $\lambda p.p\ F$ & правая проекция\\\hline
$Case$ & $\lambda l.\lambda r.\lambda c.c\ l\ r$ & case для алгебраического типа\\
$InL$ & $\lambda l.(\lambda x.\lambda y.x\ l)$ & левая инъекция\\
$InR$ & $\lambda r.(\lambda x.\lambda y.y\ r)$ & правая инъекция\\
\end{tabular}

\begin{enumerate}
\item Убедитесь, что $PrL\ (MkPair\ a\ b) \twoheadrightarrow_\beta a$.
\item Убедитесь, что $Case\ (\lambda x.T)\ (\lambda y.y)\ (InR\ p) \twoheadrightarrow_\beta p$.
\item Постройте операцию вычитания 1 из числа
\item Постройте операцию вычитания чисел
\item Постройте опреацию деления чисел
\end{enumerate}

\item Напомним определение Y-комбинатора: $\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))$.
\begin{enumerate}
\item Покажите, что выражение $Y\ f$ не имеет нормальной формы;
\item Покажите, что выражение $Y\ (\lambda f.\overline{0})$ имеет нормальную форму.
\item Покажите, что выражение $Y\ (\lambda f.\lambda x.(IsZero\ x)\ \overline{0}\ (f\ Minus1\ x))\ 2$ имеет нормальную форму.
\item Какова нормальная форма выражения $Y\ (\lambda f.\lambda x.(IsZero\ x)\ \overline{0}\ ((+1)\ (f\ Minus1\ x)))\ \overline{n}$?
\item Какова нормальная форма выражения $Y\ (\lambda f.\lambda x.(IsZero\ x)\ \overline{1}\ (Mul2\ (f\ Minus1\ x)))\ \overline{n}$?
\item Определите с помощью $Y$-комбинатора функцию для вычисления $n$-го числа Фибоначчи.
\end{enumerate}

\item Пусть $\eta = (\alpha\rightarrow\alpha)\rightarrow(\alpha\rightarrow\alpha)$. Покажите (т.е. постройте
соответствующее доказательство в исчислении по Карри), что:
\begin{enumerate}
\item $\vdash \overline{2} : \eta$.
\item $\vdash (+1) : \eta\rightarrow\eta$.
\item $\vdash Plus : \eta\rightarrow\eta$.
\item $\vdash Mul : \eta\rightarrow\eta$ (не каждая реализация умножения будет удовлетворять этому свойству;
вам требуется найти нужную)
\end{enumerate}

\item Определим на языке Хаскель следующую функцию: \verb!show_church n = show (n (+1) 0)!
Убедитесь, что \verb!show_church (\f -> \x -> f (f x))! вернёт 2. 
Пользуясь данным определением и его идеей, реализуйте следующие функции:

\begin{enumerate}
\item \verb!int_to_church! --- возвращает чёрчевский нумерал (т.е. функцию от двух аргументов) по целому числу.
Каков точный тип результата этой функции?
\item сложение двух чёрчевских нумералов.
\item умножение двух чёрчевских нумералов.
\item можно ли определить вычитание 1 и вычитание? Что получается, а что --- нет?
\end{enumerate}

\item Типы для конъюнкции и дизъюнкции на Хаскеле. Списки.

Заметим, что список (например, целых чисел) — это алгебраический тип: 

\verb!List = Nil | Cons Integer List!.

Можно сконструировать значение данного типа: \verb!Cons 3 (Cons 5 Nil)!.
Можно, например, вычислить его длину:
\begin{verbatim}
length Nil = 0
length (Cons _ tail) = length tail + 1
\end{verbatim}

Определим $Nil = InL\ 0$, а $Cons\ a\ b = InR\ (MkPair\ a\ b)$. Заметим, что теперь списки могут быть впрямую
перенесены в лямбда выражения. Тогда, используя данную идею, реализуйте в Хаскеле:

\begin{enumerate}
\item определите конструкции mkpair, prl, prr на Хаскеле --- какой тип у данных конструкций? Сравните его с типом конъюнкции с лекции.
\item определите конструкции case, inl, inr --- какой тип у данных конструкций? Сравните его с типом дизъюнкции с лекции.
\item постройте список целых чисел из данных конструкий.
\item определите функцию вычисления длины списка целых чисел с помощью данных конструкций (к сожалению, скомпилировать это
выражение на Хаскеле не получится — поэтому достаточно написать исходный код).
\end{enumerate}

\end{enumerate}

\section*{Домашнее задание №2: <<формализация лямбда-исчисления>>}

\begin{enumerate}
\item На лекции было использовано понятие свободы для подстановки. 
\begin{enumerate}
\item Найдите лямбда-выражение, которое при однократной редукции требует переименования связанных переменных
(редукция невозможна без переименования). 
\item Заметим, что даже если мы запретим использовать одни и те же переменные в разных лямбда-абстракциях,
это не будет решением проблемы переименований. Предложите лямбда-выражение, в котором (а) все лямбда-абстракции
указаны по разным переменным; но (б) через некоторое количество редукций потребуется переименование
связанных переменных.
\end{enumerate}

\item Дадим определение: комбинатор --- лямбда-выражение без свободных переменных.

Также напомним определение:
$$\begin{array}{l}
S := \lambda x.\lambda y.\lambda z.x\ z\ (y\ z)\\
K := \lambda x.\lambda y.x\\
I := \lambda x.x
\end{array}$$

Известна теорема о том, что для любого комбинатора $X$ можно найти выражение $P$
(состоящее только из скобок, пробелов и комбинаторов $S$ и $K$), что $X =_\beta P$.
Будем говорить, что комбинатор $P$ \emph{выражает} комбинатор $X$ в базисе $SK$.

Выразите в базисе $SK$:
\begin{enumerate}
\item $F = \lambda x.\lambda y.y$
\item $\overline{1}$
\item $Not$
\item $Xor$
\item $InL$
\item $\overline{n}$
\end{enumerate}

\item Бесконечное количество комбинаторов неподвижной точки. Дадим следующие определения
$$\begin{array}{l}
L := \lambda abcdefghijklmnopqstuvwxyzr.r(thisisafixedpointcombinator)\\
R := LLLLLLLLLLLLLLLLLLLLLLLLLL\end{array}$$
В данном определении терм $R$ является комбинатором неподвижной точки: каков бы ни был терм
$F$, выполнено $R\ F =_\beta F\ (R\ F)$.
\begin{enumerate}
\item Докажите, что данный комбинатор --- действительно комбинатор неподвижной точки.
\item Пусть в качестве имён переменных разрешены русские буквы. Постройте аналогичное выражение
по-русски: с 33 параметрами и осмысленной русской фразой в терме $L$; покажите, что оно является
комбинатором неподвижной точки.
\end{enumerate}

\item Пусть задано $n \in \mathbb{N}$. 
Постройте лямбда-выражение, которое преобразуется в нормальную форму в $n$ раз 
медленнее с помощью нормального порядка редукции, чем с помощью какого-то другого (самого быстрого) 
порядка редукции.

\item Чёрчевские нумералы соответствуют натуральным числам в аксиоматике Пеано.
\begin{enumerate}
\item Предложите <<двоичные нумералы>> --- способ кодирования чисел, аналогичный двоичной системе 
(такой, при котором длина записи числа соответствует логарифму числового значения).
\item Предложите реализацию функции (+1) в данном представлении.
\item Предложите реализацию лямбда-выражения преобразования числа из двоичного нумерала в чёрчевский.
\item Предложите реализацию функции сложения в данном представлении.
\item Предложите реализацию функции вычитания в данном представлении.
\item Какова вычислительная сложность арифметопераций с двоичными нумералами?
\end{enumerate}

\item Предложим альтернативные аксиомы для конъюнкции:

$$\infer[\text{Введ. }\with]{\Gamma\vdash \alpha\with \beta}{\Gamma\vdash \alpha\ \ \ \Gamma\vdash \beta}\quad\quad
  \infer[\text{Удал. }\with]{\Gamma\vdash \gamma}{\Gamma\vdash \alpha\with \beta\ \ \ \Gamma, \alpha, \beta\vdash \gamma}$$

\begin{enumerate}
\item Предложите лямбда-выражения, соответствующие данным аксиомам; поясните, как данные выражения 
абстрагируют понятие <<упорядоченной пары>>.
\item Выразите изложенные в лекции аксиомы конъюнкции через приведённые в условии.
\item Выразите приведённые в условии аксиомы конъюнкции через изложенные в лекции.
\end{enumerate}

\item Как мы уже разбирали, $\not\vdash x\ x:\tau$ в силу дополнительных ограничений
аксиомы
$$\infer[x \notin FV(\Gamma)]{\Gamma, x:\tau\vdash x:\tau}{}$$

Найдите лямбда-выражение $N$, что $\not\vdash N:\tau$ в силу ограничения аксиомы
$$\infer[x \notin FV(\Gamma)]{\Gamma \vdash \lambda x.N:\sigma\to\tau}{\Gamma, x:\sigma \vdash N:\tau}$$


\end{enumerate}

\section*{Домашнее задание №3: <<вывод типов; алгоритм унификации>>}

\begin{enumerate}

\item \emph{Вполне упорядоченным} множеством назовём такое линейно-упорядоченное отношением $(\prec)$ 
множество $S$ (и такой порядок назовём \emph{полным}), 
что какое бы ни было множество $U \subseteq S$, в $U$ найдётся наименьший элемент.
\begin{enumerate}
\item Покажите, что неотрицательные вещественные числа $[0,+\inf)$ --- не вполне упорядоченное множество.
Существуют ли конечные и счётные не вполне упорядоченные множества?
\item Определим лексикографический порядок на $\mathbb{N}^n$: положим, что 
$\langle a_1, a_2, \dots a_n \rangle \prec \langle b_1, b_2, \dots b_n$, если найдётся такой $k$,
что $a_1 = b_1$, ..., $a_{k-1} = b_{k-1}$, но $a_k < b_k$.
Покажите, что такой порядок --- полный.
\item Пусть $S$ вполне упорядочено отношением $(\prec)$, 
определим $a\succ b := b \prec a$. Пусть $a_1 \succ a_2 \succ a_3 \succ \dots$ --- 
строго монотонно убывающая последовательность значений из $S$. Покажите, что данная 
последовательность всегда имеет конечную длину.
\end{enumerate}

\item Рассмотрим полное интуиционистское исчисление высказываний.
Дополните алгоритм вывода типов дополнительными функциональными символами 
для связок $\with$, $\vee$ и $\bot$ (а также сделайте дополнительные 
необходимые исправления в нём) и продемонстрируйте вывод типов для выражения,
использующего хотя бы две из данных трёх конструкций.

\item Поясним название <<алгебраические типы>> --- это семейство составных типов, 
позволяющих строить <<алгебраические>> выражения на типах:

\begin{tabular}{lll}
название & обозначение & алгебраический смысл\\\hline
тип-сумма, <<алгебраический>> & $\alpha\vee\beta$ & $\alpha+\beta$\\
тип-произведение, пара & $\alpha\with\beta$ & $\alpha\times\beta$\\
тип-степень, функция & $\alpha\to\beta$&$\beta^\alpha$
\end{tabular}

Название <<алгебраический>> закрепилось в первую очередь за типом-суммой (видимо потому,
что остальные типы имеют устоявшиеся названия), однако, может быть отнесено и к другим
типам.

Поясните <<типовый>> (программистский) смысл следующих алгебраических тождеств --- и постройте
программы, их доказывающие:
\begin{enumerate}
\item $\gamma\times(\alpha+\beta) = \gamma\times\alpha + \gamma\times\beta$.
\item $\gamma^{\alpha\times\beta} = {(\gamma^\alpha)}^\beta$. Как называется данное тождество?
\item $\gamma^{\alpha+\beta} = \gamma^\alpha\times\gamma^\beta$.
\end{enumerate}

\item Найдите лямбда-выражения, доказывающие:
\begin{enumerate}
\item Формулу де-Моргана $\neg(\alpha\vee\beta)\to\neg\alpha\with\neg\beta$.
\item Контрапозицию $(\alpha\to\beta)\to(\neg\beta\to\neg\alpha)$.
\item Закон исключённого третьего после применения теоремы Гливенко $\neg\neg(\alpha\vee\neg\alpha)$.
\end{enumerate}

\end{enumerate}

\section*{Домашнее задание №4: <<логика второго порядка; система F>>}

\begin{enumerate}
\item Докажите в исчислени предикатов второго порядка теоремы--аналоги правил вывода для следующих связок:
\begin{enumerate}
\item конъюнкция;
\item дизъюнкция;
\item отрицание и ложь;
\item квантор существования.
\end{enumerate}

Напомним: в задании требуется по заданным аксиоме и аргументам связки найти такое дерево применений
правил И.П. 2 порядка, которым можно было бы заменить применение исходной аксиомы.

\item Напомним, что в системе F естественно предложить выражение
$\Lambda \alpha.\lambda f^{\alpha\rightarrow\alpha}.\lambda x^\alpha.f^n\ x$
как аналог для чёрчевского нумерала.
Постройте в F выражения для следующих функций и выведите их тип:
\begin{enumerate}
\item сложение;
\item умножение;
\item возведение в степень
\item вычитание 1
\end{enumerate}

\item Перенесите в систему F выражения для булевских значений и операции And и выведите их тип.

\item Выразите в языке Хаскель конструкции системы F через импликацию и квантор всеобщности. 

Точнее: запишите выражение, напишите программы, доказывающие соответствующие аксиомы, 
укажите, как преобразовать данное выражение в нативный хаскелевский тип и наоборот.
При реализации вам потребуется использовать квантор всеобщности в типах
(\verb!type T = forall x. ...!) и включить опцию RankNTypes.

Список конструкций:

\begin{enumerate}
\item конъюнкция;
\item дизъюнкция;
\item отрицание и ложь (соответствует \verb!undefined!).
\end{enumerate}

\item \emph{Экзистенциальные типы.} Укажем правила вывода для квантора существования в системе F:

$$
\infer[\text{Введ. }\exists]{\Gamma\vdash\textbf{pack }\tau, M\textbf{ to } \exists \alpha.\sigma:\exists\alpha.\sigma}{
  \Gamma\vdash M:\sigma[\alpha:=\tau]}
$$
$$
\infer[\text{Удал. }\exists; \alpha\notin FV(\Gamma,\rho)]{
  \Gamma\vdash\textbf{abstype }\alpha\textbf{ with }x:\sigma\textbf{ is }M\textbf{ in }N:\rho}{
  \Gamma\vdash M:\exists\alpha.\sigma\quad\Gamma,x:\sigma\vdash N:\rho}
$$

Постараемся прояснить смысл данных конструкций.
В объектно-ориентированных языках программирования обычно хранение данных объединено с 
библиотечной структурой: структура данных всегда неявно присутствует как параметр
методов класса. 
Аналогия с квантором существования подсказывает, что эта связь необязательна:
библиотека характеризуется сигнатурой её методов ($\sigma$) и типом, хранящим значения
($\alpha$). 

Если мы хотим задать некоторый абстрактный тип данных, мы используем pack.
Например, давайте построим АТД <<список>> в некотором обобщении лямбда-исчисления:

%abstype α with x: α & ((α → int → α) & (α → int&α)) 
%is int_stack in
%    let st: α = PrL int_stack in              // initialize
%    let st: α = (PrL (PrR int_stack)) 12 in   // push 12 into stack
%    (PrR (PrR int_stack)) st                  // pop value from stack

$$\begin{array}{l}let\ intstack=\textbf{pack }list, 
 \langle Nil, \langle(\lambda l^{list}.\lambda x^{int}.Cons\ x\ l), (\lambda l^{list}.\langle Head\ l, Tail\ l\rangle)\rangle\rangle\\
\textbf{to } \exists\alpha.\alpha\with((\alpha\rightarrow int\rightarrow\alpha)\with(\alpha\rightarrow int\with\alpha))\end{array}
$$

Если же мы желаем использовать такой АТД, мы используем abstype; вот такой код вернёт число 12:

$$\begin{array}{l}\textbf{abstype }\alpha\textbf{ with }x:  
  \alpha\with((\alpha\rightarrow int\rightarrow\alpha)\with(\alpha\rightarrow int\with\alpha)) \textbf{ is }intstack\textbf{ in}\\
let\ st^\alpha = Pr_L\ x\ in\\
let\ st^\alpha = (Pr_L\ (Pr_R\ x))\ st\ 12\ in\\
Pr_L\ ((Pr_R\ (Pr_R\ x))\ st)$$
\end{array}$$
%    let st: α = PrL int_stack in              // initialize
%    let st: α = (PrL (PrR int_stack)) 12 in   // push 12 into stack
%    (PrR (PrR int_stack)) st                  // pop value from stack


В завершение определим правило бета-редукции для данных конструкций.

$$\textbf{abstype }\alpha\textbf{ with }x:\sigma\textbf{ is pack }M,\tau\textbf{ to }\exists\alpha.\sigma\textbf{ in }N
   \rightarrow_\beta N[\alpha:=\tau][x := M]$$

\begin{enumerate}
\item Предъявите лямбда-выражение, соответствующее pack в системе F (без использования сокращений записи ---
в частности, без ($\exists$)). Покажите, что оно действительно имеет приписываемый ему тип.
\item Предъявите лямбда-выражение, соответствующее abstype в системе F (без ($\exists$)). Покажите, что оно действительно имеет приписываемый ему тип.
\item Рассмотрим вариант системы F, типизированный по Карри (отсутстуют типовые абстракции и применения, а также указания
типов в аргументах). Предложите реализацию pack и abstype в этом варианте исчисления.
\item Предложите реализацию на Хаскеле и пример использования для массива фиксированного размера (размер указывается при инициализации), 
соответствующего интерфейсу, заданному следующим экзистенциальным типом (для компиляции требуется включить опцию RankNTypes):

\begin{verbatim}
data AbstractArray x = AA (forall b . (forall a . 
     (Integer -> a, a -> (Integer, x) -> a, a -> Integer -> (a, x)) -> b) -> b)
\end{verbatim}

\item Предположим, что в Джаве мы не используем наследования, а только разрешаем реализовывать интерфейсы. 
Предложите формализацию для классов и интерфейсов с использованием экзистенциальных типов.
Как реализовать публичные и приватные поля?
\end{enumerate}
\end{enumerate}

\section*{Домашнее задание №5: <<Типовая система Хиндли-Милнера>>}

\begin{enumerate}
\item Покажите, что если $\phi$ --- тип в системе Хиндли-Милнера,
то существует $n\in \mathbb{N}_0$, что $\phi\in R(n)$.

\item Покажите, что если $\phi\in R(n)$ и $n < m$, то $\phi\in R(m)$.

\item Пусть $\phi$ --- формула И.П. ранга 1. Покажите, что существует такое выражение $\sigma$ с поверхностными кванторами,
что $\vdash\phi\rightarrow\sigma$ и $\vdash\sigma\rightarrow\phi$. Для этого:
\begin{enumerate}
\item Покажите, что если $\phi$ --- формула ранга 1, то она имеет вид либо $\xi$, либо $\forall x.\psi$, 
либо $\xi\rightarrow\psi$, где $\psi$ --- формула ранга 1, а $\xi$ --- формула ранга 0.
\item Покажите, что если $\phi = \chi\rightarrow\forall x.\psi$, где $x \notin FV(\chi)$, 
то $\vdash\phi\rightarrow(\forall x.\chi\rightarrow\psi)$ и $\vdash(\forall x.\chi\rightarrow\psi)\rightarrow\phi$.
\item Покажите, что $\vdash (\forall x.\psi)\rightarrow \forall y.\psi[x:=y]$ и $\vdash (\forall y.\psi[x:=y])\rightarrow\forall x.\psi$,
если $y$ не входит свободно в $\psi$.
\item Опираясь на утверждения выше, покажите искомое утверждение.
\end{enumerate}

\item \emph{О выразительной силе HM.} Заметим, что список --- это <<параметризованные>> числа в 
аксиоматике Пеано. Число --- это длина списка, а к каждому штриху мы присоединяем какое-то значение.
Операции добавления и удаления элемента из списка --- это операции прибавления и вычитания
единицы к числу.

Рассмотрим тип <<бинарного списка>>:

\begin{verbatim}
type 'a bin_list = Nil | Zero of (('a*'a) bin_list) | One of 'a * (('a*'a) bin_list);;
\end{verbatim}

Если бы такое можно было выразить в типовой системе Хиндли-Милнера, то операция добавления
элемента к списку записалась бы на языке Окамль вот так (сравните с прибавлением 1 к числу
в двоичной системе счисления):

\begin{verbatim}
let rec add elem lst = match lst with
    Nil -> One (elem,Nil)
  | Zero tl -> One (elem,tl)
  | One (hd,tl) -> Zero (add (elem,hd) tl)
\end{verbatim}

\begin{enumerate}
\item Какой тип имеет \verb!add! (обратите внимание на ключевое слово \verb!rec!: для 
точного указания соответствующего лямбда-выражения и вывода типа необходимо использовать Y-комбинатор)?
Считайте, что семейство типов \verb!bin_list 'a! предопределено, и обозначается как $\tau_\alpha$.
Также считайте, что определены функции roll и unroll с надлежащими типами.
\item Какой ранг имеет тип этой функции? Почему этот тип не выразим в типовой системе Хиндли-Милнера?
\item Предложите функцию для удаления элемента списка (головы).
\item Предложите функцию для эффективного соединения двух списков (источник для 
вдохновения --- сложение двух чисел в столбик).
\item Предложите функцию для эффективного выделения $n$-го элемента из списка.
\end{enumerate}

\item Используя расширения системы Хиндли-Милнера (изо-рекурсивные типы и $Y$-комбинатор), 
определите тип для списка и реализуйте функцию, вычисляющую длину списка.

\item Выразите Y-комбинатор в Хаскеле и докажите с его помощью, что $\phi\rightarrow\neg\phi$,
$\alpha\rightarrow\alpha\with\beta$ и $\neg\neg\phi\rightarrow\phi$.

\item Постройте в HM вывод (дерево из аксиом и правил вывода) для
$\textbf{let }t = \lambda f.\lambda x.f\ x \textbf{ in }t\ t$.

\item Рассмотрим следующий код на Окамле, содержащий определения чёрчевских нумералов
и некоторых простых операций с ними:

\begin{verbatim}
let zero = fun f x -> x;;
let plus1 a = fun f -> fun x -> a f (f x);;
let power m n = n m;;

let two = plus1 (plus1 zero);;
let two2 = fun f x -> f (f x);;

let e  = power two two;;          (* не компилируется *)
let e2 = power two2 two2;;        (* компилируется и работает *)
\end{verbatim}

Поясните, почему:
\begin{enumerate}
\item определение $e2$ компилируется и работает;
\item определение $e$ не компилируется.
\end{enumerate}

Пояснение должно содержать необходимые фрагменты вывода типа в системе Хиндли-Милнера, 
или должно показывать, что нужного вывода типа не существует.
\end{enumerate}

\section*{Домашнее задание №6: <<Обобщённые типовые системы, исчисление конструкций>>}

\begin{enumerate}
\item Укажите тип (род) в исчислении конструкций для следующих выражений (при необходимости определите
типы используемых базовых операций и конструкций самостоятельно):
\begin{enumerate}
\item В алгебраическом типе \verb!'a option = None | Some 'a! предложите тип (род) для: \verb!Some!,
\verb!None! и \verb!option!.
\item Пусть задан род $\textbf{nonzero}: \star\rightarrow\star$, выбрасывающий нулевой элемент из
типа. Например, $\textbf{nonzero}\ \textbf{unsigned}$ --- тип положительных целых чисел.
Тогда, для кода
\begin{verbatim}
template<typename T, T x>
struct NonZero { const static std::enable_if_t<x != T(0), T> value = x; };
\end{verbatim}
предложите тип (род) поля value.
\end{enumerate}

\item Предложите выражение на языке C++ (возможно, использующее шаблоны), имеющее следующий род (тип):
\begin{enumerate}
\item $\star\rightarrow\star\rightarrow\star$; $\ \star\rightarrow\textbf{unsigned}$
\item $\textbf{int}\rightarrow(\star\rightarrow\star)$
\item $(\star\rightarrow\textbf{int})\rightarrow\star$
\item $\Pi x^\star.n^\textbf{int}.F(n,x)$, где $$F(n,x) = \left\{\begin{array}{ll}\textbf{int}, & n = 0\\
                                   x\rightarrow F(n,x), & n > 0\end{array}\right.$$
\end{enumerate}

\item Аналогично типу $\Pi$, мы можем ввести тип $\Sigma$, соответствующий квантору существования
в смысле изоморфизма Карри-Ховарда. 
\begin{enumerate}
\item Определите правила вывода для $\Sigma$ в обобщённой типовой системе (воспользуйтесь правилами
для экзистенциальных типов в системе $F$).
\item Укажите способ выразить $\Sigma$ через $\Pi$ (также воспользуйтесь идеями для системы $F$).
\end{enumerate}


%\item Парадокс Жирара. Известно, что если слишком серьёзно расширить теорию, то она станет неразрешимой.
%
%Рассмотрим новый сорт для родов, $\triangle$, примем $S = \{\star, \square, \triangle\}$.
%Рассмотрим исчисление $U$, построенное аналогично типовым системам из лямбда-куба, с двумя аксиомами
%($\star : \square$ и $\square : \triangle$) и пятью парами правил ($(\star,\star), (\square,\star),
%(\square,\square), (\triangle,\star), (\triangle,\square)$).
%\begin{enumerate}
%\end{enumerate}
\end{enumerate}

\end{document}
