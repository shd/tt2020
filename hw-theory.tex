\documentclass[10pt,a4paper,oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{stmaryrd}
\usepackage{cmll}
\usepackage{mathrsfs}
\usepackage{hyperref}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{proof}
\usepackage{tikz}
\usepackage{multicol}

\makeatletter
\newcommand{\dotminus}{\mathbin{\text{\@dotminus}}}

\newcommand{\@dotminus}{%
  \ooalign{\hidewidth\raise1ex\hbox{.}\hidewidth\cr$\m@th-$\cr}%
}
\makeatother

\usetikzlibrary{arrows,backgrounds,patterns,matrix,shapes,fit,calc,shadows,plotmarks}

\newtheorem{definition}{Определение}
\begin{document}

\begin{center}{\Large\textsc{\textbf{Теоретические (``малые'') домашние задания}}}\\
             \it Теория типов, ИТМО, М3235-М3239, весна 2020 года\end{center}

\section*{Домашнее задание №1: <<вводная лекция для ТТ и ФП>>}

\begin{enumerate}

\item Напомним определения с лекций:

\begin{tabular}{lll}
Обозначение & лямбда-терм & название\\\hline
$T$ & $\lambda a.\lambda b.a$ & истина\\
$F$ & $\lambda a.\lambda b.b$ & ложь\\
$Not$ & $\lambda x.x\ F\ T$ & отрицание\\
$And$ & $\lambda x.\lambda y.x\ y\ F$ & конъюнкция
\end{tabular}

Проредуцируйте следующие выражения и найдите нормальную форму:

\begin{enumerate}
\item $T\ F$
\item $(T\ Not\ (\lambda t.t))\ F$
\item $And\ F\ T$
\item $And\ T\ T$
\end{enumerate}

\item Постройте лямбда-выражения для следующих булевских выражений:
\begin{enumerate}
\item Дизъюнкция
\item Штрих Шеффера (<<и-не>>)
\item Исключающее или
\end{enumerate}

\item Напомним определения с лекций:

$$f^{(n)}\ X ::= \left\{\begin{array}{ll} X, & n=0\\
                                f^{(n-1)}\ (f\ X), & n>0\end{array}\right.$$

\begin{center}\begin{tabular}{lll}
Обозначение & лямбда-терм & название\\\hline
$\overline{n}$ & $\lambda f.\lambda x.f^{(n)}\ x$ & чёрчевский нумерал\\
$(+1)$ & $\lambda n.\lambda f.\lambda x.n\ f\ (f\ x)$ & прибавление 1\\
$IsZero$ & $\lambda n.n\ (\lambda x.F)\ T$ & проверка на 0
\end{tabular}\end{center}

Используя данные определения, постройте выражения для следующих операций над числами:

\begin{enumerate}
\item Сложение
\item Умножение на 2 ($Mul2$)
\item Умножение
\item Возведение в степень
\item Проверка на чётность
\item Деление на 3 (могут потребоваться пары и/или вычитания)
\item Сравнение двух чисел ($IsLess$) — истина, если первый аргумент меньше второго
(могут потребоваться пары и/или вычитания)
\end{enumerate}

\item Проредуцируйте выражение и найдите его нормальную форму: 
\begin{enumerate}
\item $\overline{2}\ \overline{2}$
\item $\overline{2}\ \overline{2}\ \overline{2}$
\item $\overline{2}\ \overline{2}\ \overline{2}\ \overline{2}\ \overline{2}\ \overline{2}\ \overline{2}$
\end{enumerate}

\item Напомним определения с лекций:

\begin{tabular}{lll}
Обозначение & лямбда-терм & название\\\hline
$MkPair$ & $\lambda a.\lambda b.(\lambda x.x\ a\ b)$ & создание пары\\
$PrL$ & $\lambda p.p\ T$ & левая проекция\\
$PrR$ & $\lambda p.p\ F$ & правая проекция\\\hline
$Case$ & $\lambda l.\lambda r.\lambda c.c\ l\ r$ & case для алгебраического типа\\
$InL$ & $\lambda l.(\lambda x.\lambda y.x\ l)$ & левая инъекция\\
$InR$ & $\lambda r.(\lambda x.\lambda y.y\ r)$ & правая инъекция\\
\end{tabular}

\begin{enumerate}
\item Убедитесь, что $PrL\ (MkPair\ a\ b) \twoheadrightarrow_\beta a$.
\item Убедитесь, что $Case\ (\lambda x.T)\ (\lambda y.y)\ (InR\ p) \twoheadrightarrow_\beta p$.
\item Постройте операцию вычитания 1 из числа
\item Постройте операцию вычитания чисел
\item Постройте опреацию деления чисел
\end{enumerate}

\item Напомним определение Y-комбинатора: $\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))$.
\begin{enumerate}
\item Покажите, что выражение $Y\ f$ не имеет нормальной формы;
\item Покажите, что выражение $Y\ (\lambda f.\overline{0})$ имеет нормальную форму.
\item Покажите, что выражение $Y\ (\lambda f.\lambda x.(IsZero\ x)\ \overline{0}\ (f\ Minus1\ x))\ 2$ имеет нормальную форму.
\item Какова нормальная форма выражения $Y\ (\lambda f.\lambda x.(IsZero\ x)\ \overline{0}\ ((+1)\ (f\ Minus1\ x)))\ \overline{n}$?
\item Какова нормальная форма выражения $Y\ (\lambda f.\lambda x.(IsZero\ x)\ \overline{1}\ (Mul2\ (f\ Minus1\ x)))\ \overline{n}$?
\item Определите с помощью $Y$-комбинатора функцию для вычисления $n$-го числа Фибоначчи.
\end{enumerate}

\item Пусть $\eta = (\alpha\rightarrow\alpha)\rightarrow(\alpha\rightarrow\alpha)$. Покажите (т.е. постройте
соответствующее доказательство в исчислении по Карри), что:
\begin{enumerate}
\item $\vdash \overline{2} : \eta$.
\item $\vdash (+1) : \eta\rightarrow\eta$.
\item $\vdash Plus : \eta\rightarrow\eta$.
\item $\vdash Mul : \eta\rightarrow\eta$ (не каждая реализация умножения будет удовлетворять этому свойству;
вам требуется найти нужную)
\end{enumerate}

\item Определим на языке Хаскель следующую функцию: \verb!show_church n = show (n (+1) 0)!
Убедитесь, что \verb!show_church (\f -> \x -> f (f x))! вернёт 2. 
Пользуясь данным определением и его идеей, реализуйте следующие функции:

\begin{enumerate}
\item \verb!int_to_church! --- возвращает чёрчевский нумерал (т.е. функцию от двух аргументов) по целому числу.
Каков точный тип результата этой функции?
\item сложение двух чёрчевских нумералов.
\item умножение двух чёрчевских нумералов.
\item можно ли определить вычитание 1 и вычитание? Что получается, а что --- нет?
\end{enumerate}

\item Типы для конъюнкции и дизъюнкции на Хаскеле. Списки.

Заметим, что список (например, целых чисел) — это алгебраический тип: 

\verb!List = Nil | Cons Integer List!.

Можно сконструировать значение данного типа: \verb!Cons 3 (Cons 5 Nil)!.
Можно, например, вычислить его длину:
\begin{verbatim}
length Nil = 0
length (Cons _ tail) = length tail + 1
\end{verbatim}

Определим $Nil = InL\ 0$, а $Cons\ a\ b = InR\ (MkPair\ a\ b)$. Заметим, что теперь списки могут быть впрямую
перенесены в лямбда выражения. Тогда, используя данную идею, реализуйте в Хаскеле:

\begin{enumerate}
\item определите конструкции mkpair, prl, prr на Хаскеле --- какой тип у данных конструкций? Сравните его с типом конъюнкции с лекции.
\item определите конструкции case, inl, inr --- какой тип у данных конструкций? Сравните его с типом дизъюнкции с лекции.
\item постройте список целых чисел из данных конструкий.
\item определите функцию вычисления длины списка целых чисел с помощью данных конструкций (к сожалению, скомпилировать это
выражение на Хаскеле не получится — поэтому достаточно написать исходный код).
\end{enumerate}

\end{enumerate}

\section*{Домашнее задание №2: <<формализация лямбда-исчисления>>}

\begin{enumerate}
\item На лекции было использовано понятие свободы для подстановки. 
\begin{enumerate}
\item Найдите лямбда-выражение, которое при однократной редукции требует переименования связанных переменных
(редукция невозможна без переименования). 
\item Заметим, что даже если мы запретим использовать одни и те же переменные в разных лямбда-абстракциях,
это не будет решением проблемы переименований. Предложите лямбда-выражение, в котором (а) все лямбда-абстракции
указаны по разным переменным; но (б) через некоторое количество редукций потребуется переименование
связанных переменных.
\end{enumerate}

\item Дадим определение: комбинатор --- лямбда-выражение без свободных переменных.

Также напомним определение:
$$\begin{array}{l}
S := \lambda x.\lambda y.\lambda z.x\ z\ (y\ z)\\
K := \lambda x.\lambda y.x\\
I := \lambda x.x
\end{array}$$

Известна теорема о том, что для любого комбинатора $X$ можно найти выражение $P$
(состоящее только из скобок, пробелов и комбинаторов $S$ и $K$), что $X =_\beta P$.
Будем говорить, что комбинатор $P$ \emph{выражает} комбинатор $X$ в базисе $SK$.

Выразите в базисе $SK$:
\begin{enumerate}
\item $F = \lambda x.\lambda y.y$
\item $\overline{1}$
\item $Not$
\item $Xor$
\item $InL$
\item $\overline{n}$
\end{enumerate}

\item Бесконечное количество комбинаторов неподвижной точки. Дадим следующие определения
$$\begin{array}{l}
L := \lambda abcdefghijklmnopqstuvwxyzr.r(thisisafixedpointcombinator)\\
R := LLLLLLLLLLLLLLLLLLLLLLLLLL\end{array}$$
В данном определении терм $R$ является комбинатором неподвижной точки: каков бы ни был терм
$F$, выполнено $R\ F =_\beta F\ (R\ F)$.
\begin{enumerate}
\item Докажите, что данный комбинатор --- действительно комбинатор неподвижной точки.
\item Пусть в качестве имён переменных разрешены русские буквы. Постройте аналогичное выражение
по-русски: с 33 параметрами и осмысленной русской фразой в терме $L$; покажите, что оно является
комбинатором неподвижной точки.
\end{enumerate}

\item Пусть задано $n \in \mathbb{N}$. 
Постройте лямбда-выражение, которое преобразуется в нормальную форму в $n$ раз 
медленнее с помощью нормального порядка редукции, чем с помощью какого-то другого (самого быстрого) 
порядка редукции.

\item Чёрчевские нумералы соответствуют натуральным числам в аксиоматике Пеано.
\begin{enumerate}
\item Предложите <<двоичные нумералы>> --- способ кодирования чисел, аналогичный двоичной системе 
(такой, при котором длина записи числа соответствует логарифму числового значения).
\item Предложите реализацию функции (+1) в данном представлении.
\item Предложите реализацию лямбда-выражения преобразования числа из двоичного нумерала в чёрчевский.
\item Предложите реализацию функции сложения в данном представлении.
\item Предложите реализацию функции вычитания в данном представлении.
\item Какова вычислительная сложность арифметопераций с двоичными нумералами?
\end{enumerate}

\item Предложим альтернативные аксиомы для конъюнкции:

$$\infer[\text{Введ. }\with]{\Gamma\vdash \alpha\with \beta}{\Gamma\vdash \alpha\ \ \ \Gamma\vdash \beta}\quad\quad
  \infer[\text{Удал. }\with]{\Gamma\vdash \gamma}{\Gamma\vdash \alpha\with \beta\ \ \ \Gamma, \alpha, \beta\vdash \gamma}$$

\begin{enumerate}
\item Предложите лямбда-выражения, соответствующие данным аксиомам; поясните, как данные выражения 
абстрагируют понятие <<упорядоченной пары>>.
\item Выразите изложенные в лекции аксиомы конъюнкции через приведённые в условии.
\item Выразите приведённые в условии аксиомы конъюнкции через изложенные в лекции.
\end{enumerate}

\item Как мы уже разбирали, $\not\vdash x\ x:\tau$ в силу дополнительных ограничений
аксиомы
$$\infer[x \notin FV(\Gamma)]{\Gamma, x:\tau\vdash x:\tau}{}$$

Найдите лямбда-выражение $N$, что $\not\vdash N:\tau$ в силу ограничения аксиомы
$$\infer[x \notin FV(\Gamma)]{\Gamma \vdash \lambda x.N:\sigma\to\tau}{\Gamma, x:\sigma \vdash N:\tau}$$


\end{enumerate}

\section*{Домашнее задание №3: <<вывод типов; алгоритм унификации>>}

\begin{enumerate}

\item \emph{Вполне упорядоченным} множеством назовём такое линейно-упорядоченное отношением $(\prec)$ 
множество $S$ (и такой порядок назовём \emph{полным}), 
что какое бы ни было множество $U \subseteq S$, в $U$ найдётся наименьший элемент.
\begin{enumerate}
\item Покажите, что неотрицательные вещественные числа $[0,+\inf)$ --- не вполне упорядоченное множество.
Существуют ли конечные и счётные не вполне упорядоченные множества?
\item Определим лексикографический порядок на $\mathbb{N}^n$: положим, что 
$\langle a_1, a_2, \dots a_n \rangle \prec \langle b_1, b_2, \dots b_n$, если найдётся такой $k$,
что $a_1 = b_1$, ..., $a_{k-1} = b_{k-1}$, но $a_k < b_k$.
Покажите, что такой порядок --- полный.
\item Пусть $S$ вполне упорядочено отношением $(\prec)$, 
определим $a\succ b := b \prec a$. Пусть $a_1 \succ a_2 \succ a_3 \succ \dots$ --- 
строго монотонно убывающая последовательность значений из $S$. Покажите, что данная 
последовательность всегда имеет конечную длину.
\end{enumerate}

\item Рассмотрим полное интуиционистское исчисление высказываний.
Дополните алгоритм вывода типов дополнительными функциональными символами 
для связок $\with$, $\vee$ и $\bot$ (а также сделайте дополнительные 
необходимые исправления в нём) и продемонстрируйте вывод типов для выражения,
использующего хотя бы две из данных трёх конструкций.

\item Поясним название <<алгебраические типы>> --- это семейство составных типов, 
позволяющих строить <<алгебраические>> выражения на типах:

\begin{tabular}{lll}
название & обозначение & алгебраический смысл\\\hline
тип-сумма, <<алгебраический>> & $\alpha\vee\beta$ & $\alpha+\beta$\\
тип-произведение, пара & $\alpha\with\beta$ & $\alpha\times\beta$\\
тип-степень, функция & $\alpha\to\beta$&$\beta^\alpha$
\end{tabular}

Название <<алгебраический>> закрепилось в первую очередь за типом-суммой (видимо потому,
что остальные типы имеют устоявшиеся названия), однако, может быть отнесено и к другим
типам.

Поясните <<типовый>> (программистский) смысл следующих алгебраических тождеств --- и постройте
программы, их доказывающие:
\begin{enumerate}
\item $\gamma\times(\alpha+\beta) = \gamma\times\alpha + \gamma\times\beta$.
\item $\gamma^{\alpha\times\beta} = {(\gamma^\alpha)}^\beta$. Как называется данное тождество?
\item $\gamma^{\alpha+\beta} = \gamma^\alpha\times\gamma^\beta$.
\end{enumerate}

\item Найдите лямбда-выражения, доказывающие:
\begin{enumerate}
\item Формулу де-Моргана $\neg(\alpha\vee\beta)\to\neg\alpha\with\neg\beta$.
\item Контрапозицию $(\alpha\to\beta)\to(\neg\beta\to\neg\alpha)$.
\item Закон исключённого третьего после применения теоремы Гливенко $\neg\neg(\alpha\vee\neg\alpha)$.
\end{enumerate}

\end{enumerate}

\section*{Домашнее задание №4: <<логика второго порядка; система F>>}

\begin{enumerate}
\item Докажите в исчислени предикатов второго порядка теоремы--аналоги правил вывода для следующих связок:
\begin{enumerate}
\item конъюнкция;
\item дизъюнкция;
\item отрицание и ложь;
\item квантор существования.
\end{enumerate}

Напомним: в задании требуется по заданным аксиоме и аргументам связки найти такое дерево применений
правил И.П. 2 порядка, которым можно было бы заменить применение исходной аксиомы.

\item Напомним, что в системе F естественно предложить выражение
$\Lambda \alpha.\lambda f^{\alpha\rightarrow\alpha}.\lambda x^\alpha.f^n\ x$
как аналог для чёрчевского нумерала.
Постройте в F выражения для следующих функций и выведите их тип:
\begin{enumerate}
\item сложение;
\item умножение;
\item возведение в степень
\item вычитание 1
\end{enumerate}

\item Перенесите в систему F выражения для булевских значений и операции And и выведите их тип.

\item Выразите в языке Хаскель конструкции системы F через импликацию и квантор всеобщности. 

Точнее: запишите выражение, напишите программы, доказывающие соответствующие аксиомы, 
укажите, как преобразовать данное выражение в нативный хаскелевский тип и наоборот.
При реализации вам потребуется использовать квантор всеобщности в типах
(\verb!type T = forall x. ...!) и включить опцию RankNTypes.

Список конструкций:

\begin{enumerate}
\item конъюнкция;
\item дизъюнкция;
\item отрицание и ложь (соответствует \verb!undefined!).
\end{enumerate}

\item \emph{Экзистенциальные типы.} Укажем правила вывода для квантора существования в системе F:

$$
\infer[\text{Введ. }\exists]{\Gamma\vdash\textbf{pack }\tau, M\textbf{ to } \exists \alpha.\sigma:\exists\alpha.\sigma}{
  \Gamma\vdash M:\sigma[\alpha:=\tau]}
$$
$$
\infer[\text{Удал. }\exists; \alpha\notin FV(\Gamma,\rho)]{
  \Gamma\vdash\textbf{abstype }\alpha\textbf{ with }x:\sigma\textbf{ is }M\textbf{ in }N:\rho}{
  \Gamma\vdash M:\exists\alpha.\sigma\quad\Gamma,x:\sigma\vdash N:\rho}
$$

Постараемся прояснить смысл данных конструкций.
В объектно-ориентированных языках программирования обычно хранение данных объединено с 
библиотечной структурой: структура данных всегда неявно присутствует как параметр
методов класса. 
Аналогия с квантором существования подсказывает, что эта связь необязательна:
библиотека характеризуется сигнатурой её методов ($\sigma$) и типом, хранящим значения
($\alpha$). 

Если мы хотим задать некоторый абстрактный тип данных, мы используем pack.
Например, давайте построим АТД <<список>> в некотором обобщении лямбда-исчисления:

%abstype α with x: α & ((α → int → α) & (α → int&α)) 
%is int_stack in
%    let st: α = PrL int_stack in              // initialize
%    let st: α = (PrL (PrR int_stack)) 12 in   // push 12 into stack
%    (PrR (PrR int_stack)) st                  // pop value from stack

$$\begin{array}{l}let\ intstack=\textbf{pack }list, 
 \langle Nil, \langle(\lambda l^{list}.\lambda x^{int}.Cons\ x\ l), (\lambda l^{list}.\langle Head\ l, Tail\ l\rangle)\rangle\rangle\\
\textbf{to } \exists\alpha.\alpha\with((\alpha\rightarrow int\rightarrow\alpha)\with(\alpha\rightarrow int\with\alpha))\end{array}
$$

Если же мы желаем использовать такой АТД, мы используем abstype; вот такой код вернёт число 12:

$$\begin{array}{l}\textbf{abstype }\alpha\textbf{ with }x:  
  \alpha\with((\alpha\rightarrow int\rightarrow\alpha)\with(\alpha\rightarrow int\with\alpha)) \textbf{ is }intstack\textbf{ in}\\
let\ st^\alpha = Pr_L\ x\ in\\
let\ st^\alpha = (Pr_L\ (Pr_R\ x))\ st\ 12\ in\\
Pr_L\ ((Pr_R\ (Pr_R\ x))\ st)
\end{array}$$
%    let st: α = PrL int_stack in              // initialize
%    let st: α = (PrL (PrR int_stack)) 12 in   // push 12 into stack
%    (PrR (PrR int_stack)) st                  // pop value from stack


В завершение определим правило бета-редукции для данных конструкций.

$$\textbf{abstype }\alpha\textbf{ with }x:\sigma\textbf{ is pack }M,\tau\textbf{ to }\exists\alpha.\sigma\textbf{ in }N
   \rightarrow_\beta N[\alpha:=\tau][x := M]$$

\begin{enumerate}
\item Предъявите лямбда-выражение, соответствующее pack в системе F (без использования сокращений записи ---
в частности, без ($\exists$)). Покажите, что оно действительно имеет приписываемый ему тип.
\item Предъявите лямбда-выражение, соответствующее abstype в системе F (без ($\exists$)). Покажите, что оно действительно имеет приписываемый ему тип.
\item Рассмотрим вариант системы F, типизированный по Карри (отсутстуют типовые абстракции и применения, а также указания
типов в аргументах). Предложите реализацию pack и abstype в этом варианте исчисления.
\item Предложите реализацию на Хаскеле и пример использования для массива фиксированного размера (размер указывается при инициализации), 
соответствующего интерфейсу, заданному следующим экзистенциальным типом (для компиляции требуется включить опцию RankNTypes):

\begin{verbatim}
data AbstractArray x = AA (forall b . (forall a . 
     (Integer -> a, a -> (Integer, x) -> a, a -> Integer -> (a, x)) -> b) -> b)
\end{verbatim}

\item Предположим, что в Джаве мы не используем наследования, а только разрешаем реализовывать интерфейсы. 
Предложите формализацию для классов и интерфейсов с использованием экзистенциальных типов.
Как реализовать публичные и приватные поля?
\end{enumerate}
\end{enumerate}

\section*{Домашнее задание №5: <<Типовая система Хиндли-Милнера>>}

\begin{enumerate}
\item Покажите, что если $\phi$ --- тип в системе Хиндли-Милнера,
то существует $n\in \mathbb{N}_0$, что $\phi\in R(n)$.

\item Покажите, что если $\phi\in R(n)$ и $n < m$, то $\phi\in R(m)$.

\item Пусть $\phi$ --- формула И.П. ранга 1. Покажите, что существует такое выражение $\sigma$ с поверхностными кванторами,
что $\vdash\phi\rightarrow\sigma$ и $\vdash\sigma\rightarrow\phi$. Для этого:
\begin{enumerate}
\item Покажите, что если $\phi$ --- формула ранга 1, то она имеет вид либо $\xi$, либо $\forall x.\psi$, 
либо $\xi\rightarrow\psi$, где $\psi$ --- формула ранга 1, а $\xi$ --- формула ранга 0.
\item Покажите, что если $\phi = \chi\rightarrow\forall x.\psi$, где $x \notin FV(\chi)$, 
то $\vdash\phi\rightarrow(\forall x.\chi\rightarrow\psi)$ и $\vdash(\forall x.\chi\rightarrow\psi)\rightarrow\phi$.
\item Покажите, что $\vdash (\forall x.\psi)\rightarrow \forall y.\psi[x:=y]$ и $\vdash (\forall y.\psi[x:=y])\rightarrow\forall x.\psi$,
если $y$ не входит свободно в $\psi$.
\item Опираясь на утверждения выше, покажите искомое утверждение.
\end{enumerate}

\item \emph{О выразительной силе HM.} Заметим, что список --- это <<параметризованные>> числа в 
аксиоматике Пеано. Число --- это длина списка, а к каждому штриху мы присоединяем какое-то значение.
Операции добавления и удаления элемента из списка --- это операции прибавления и вычитания
единицы к числу.

Рассмотрим тип <<бинарного списка>>:

\begin{verbatim}
type 'a bin_list = Nil | Zero of (('a*'a) bin_list) | One of 'a * (('a*'a) bin_list);;
\end{verbatim}

Если бы такое можно было выразить в типовой системе Хиндли-Милнера, то операция добавления
элемента к списку записалась бы на языке Окамль вот так (сравните с прибавлением 1 к числу
в двоичной системе счисления):

\begin{verbatim}
let rec add elem lst = match lst with
    Nil -> One (elem,Nil)
  | Zero tl -> One (elem,tl)
  | One (hd,tl) -> Zero (add (elem,hd) tl)
\end{verbatim}

\begin{enumerate}
\item Какой тип имеет \verb!add! (обратите внимание на ключевое слово \verb!rec!: для 
точного указания соответствующего лямбда-выражения и вывода типа необходимо использовать Y-комбинатор)?
Считайте, что семейство типов \verb!bin_list 'a! предопределено, и обозначается как $\tau_\alpha$.
Также считайте, что определены функции roll и unroll с надлежащими типами.
\item Какой ранг имеет тип этой функции? Почему этот тип не выразим в типовой системе Хиндли-Милнера?
\item Предложите функцию для удаления элемента списка (головы).
\item Предложите функцию для эффективного соединения двух списков (источник для 
вдохновения --- сложение двух чисел в столбик).
\item Предложите функцию для эффективного выделения $n$-го элемента из списка.
\end{enumerate}

\item Используя расширения системы Хиндли-Милнера (изо-рекурсивные типы и $Y$-комбинатор), 
определите тип для списка и реализуйте функцию, вычисляющую длину списка.

\item Выразите Y-комбинатор в Хаскеле и докажите с его помощью, что $\phi\rightarrow\neg\phi$,
$\alpha\rightarrow\alpha\with\beta$ и $\neg\neg\phi\rightarrow\phi$.

\item Постройте в HM вывод (дерево из аксиом и правил вывода) для
$\textbf{let }t = \lambda f.\lambda x.f\ x \textbf{ in }t\ t$.

\item Рассмотрим следующий код на Окамле, содержащий определения чёрчевских нумералов
и некоторых простых операций с ними:

\begin{verbatim}
let zero = fun f x -> x;;
let plus1 a = fun f -> fun x -> a f (f x);;
let power m n = n m;;

let two = plus1 (plus1 zero);;
let two2 = fun f x -> f (f x);;

let e  = power two two;;          (* не компилируется *)
let e2 = power two2 two2;;        (* компилируется и работает *)
\end{verbatim}

Поясните, почему:
\begin{enumerate}
\item определение $e2$ компилируется и работает;
\item определение $e$ не компилируется.
\end{enumerate}

Пояснение должно содержать необходимые фрагменты вывода типа в системе Хиндли-Милнера, 
или должно показывать, что нужного вывода типа не существует.
\end{enumerate}

\section*{Домашнее задание №6: <<Обобщённые типовые системы, исчисление конструкций>>}

\begin{enumerate}
\item Укажите тип (род) в исчислении конструкций для следующих выражений (при необходимости определите
типы используемых базовых операций и конструкций самостоятельно):
\begin{enumerate}
\item В алгебраическом типе \verb!'a option = None | Some 'a! предложите тип (род) для: \verb!Some!,
\verb!None! и \verb!option!.
\item Пусть задан род $\textbf{nonzero}: \star\rightarrow\star$, выбрасывающий нулевой элемент из
типа. Например, $\textbf{nonzero}\ \textbf{unsigned}$ --- тип положительных целых чисел.
Тогда, для кода
\begin{verbatim}
template<typename T, T x>
struct NonZero { const static std::enable_if_t<x != T(0), T> value = x; };
\end{verbatim}
предложите тип (род) поля value.
\end{enumerate}

\item Предложите выражение на языке C++ (возможно, использующее шаблоны), имеющее следующий род (тип):
\begin{enumerate}
\item $\star\rightarrow\star\rightarrow\star$; $\ \star\rightarrow\textbf{unsigned}$
\item $\textbf{int}\rightarrow(\star\rightarrow\star)$
\item $(\star\rightarrow\textbf{int})\rightarrow\star$
\item $\Pi x^\star.n^\textbf{int}.F(n,x)$, где $$F(n,x) = \left\{\begin{array}{ll}\textbf{int}, & n = 0\\
                                   x\rightarrow F(n,x), & n > 0\end{array}\right.$$
\end{enumerate}

\item Аналогично типу $\Pi$, мы можем ввести тип $\Sigma$, соответствующий квантору существования
в смысле изоморфизма Карри-Ховарда. 
\begin{enumerate}
\item Определите правила вывода для $\Sigma$ в обобщённой типовой системе (воспользуйтесь правилами
для экзистенциальных типов в системе $F$).
\item Укажите способ выразить $\Sigma$ через $\Pi$ (также воспользуйтесь идеями для системы $F$).
\end{enumerate}
\end{enumerate}

\section*{Домашнее задание №7: <<Теория множеств>>}

\begin{enumerate}
\item Пусть $a$ и $b$ --- пустые множества. Покажите, что $a$ = $b$.

\item Построение множеств. Покажите, что если $a$, $b$ --- множества, то следующие <<наивные>>
конструкции тоже являются множествами:
\begin{enumerate}
\item $\bigcap a$ (пересечение всех подмножеств множества $a$);
\item $a \setminus b$ (разность множеств);
\item $a \uplus b$ (дизъюнктное объединение множеств);
\item $a \times b$ (декартово произведение множеств: $\{\langle p,q\rangle\ |\ p\in a, q\in b\}$).
\end{enumerate}

\item Покажите, что если $\langle a,b \rangle = \langle c,d\rangle$, то $a=b$ и $c=d$.

\item \emph{Последовательностью} элементов из $S$ длиной $k$ назовём 
множество $A$ пар $\langle o, s\rangle$, что:
\begin{enumerate}
\item $o\in k$, $s \in S$;
\item нет таких двух пар $\langle o_1, s_1\rangle$ и $\langle o_2, s_2\rangle$, что $o_1 = o_2$ и $s_1 \ne s_2$;
\item $\langle 0, s\rangle \in A$ при некотором $s$;
\item Если $\langle o, s_1 \rangle \in A$ и $o' \in k$, то $\langle o', s_2 \rangle \in A$ при некотором $s_2$.
\end{enumerate}
Будем записывать элементы последовательности как $s_o$ и говорить что
они занумерованы ординалами до $k$.

Пусть $a_0, a_1, a_2, \dots$ --- некоторая убывающая последовательность ординалов,
занумерованных до некоторого ординала $k$:
то есть, $a_i$ --- ординал, и, если $i \in j$, то $a_j \in a_i$. 
Покажите, что тогда ординал $k$ --- конечный.

\item Давайте покажем, что ординалы линейно упорядочены.
\begin{enumerate}
\item Пусть $a$ --- ординал. Покажите, что $\varnothing \in a$ или $a = \varnothing$.
\item Пусть $a$ --- ординал. Покажите, что если $x \in a$, то $x$ --- ординал.
\item Пусть $a$ и $b$ --- ординалы, и $a \in b$. Покажите, что $a' \in b$ или $a = b$.
\item Пусть $a$ и $b$ --- два ординала. Покажите, что $a\in b$, или $b \in a$, или $a = b$.
\end{enumerate}                                      

\item Покажите, что ординалы вполне упорядочены.

\item Пусть $S$ --- множество ординалов: если $x \in S$, то $x$ --- ординал.
Определите операцию $\sup_{ord} S$ --- строящую минимальный ординал $k$, что
$x\in k$, если $x \in S$.

\item Упростите по необходимости левую и правую часть равенств на ординалах и проверьте равенства:
\begin{enumerate}
\item $(\omega+1)^2 = \omega^2 + \omega\cdot 2 + 1$;
\item $(\omega+\omega)^2 = \omega^2 \cdot 4$;
\item $(\omega^2)^\omega = \omega^\omega$;
\item $1^\omega = \omega$;
\item $2^\omega = \omega$;
\item $(\omega+1)\cdot\omega = \omega^2 + \omega$;
\item $(\omega+1)^\omega = \omega^\omega + 1$.
\end{enumerate}
\end{enumerate}

%\section*{Домашнее задание №8: <<Мощность множеств>>}
%\begin{enumerate}
%\item Пусть $f: A\rightarrow B$ и $g: B\rightarrow A$ --- инъективные функции.
%Пусть $C_0 = A\setminus g(B)$, $C_{n+1} = g(f(C_n))$, $C = \bigcup_i C_i$, и пусть
%$$h(x) = \left\{\begin{array}{ll}f(x),& x \notin C\\g^{-1}(x),& x \in C\end{array}\right.$$
%
%Покажите, что h(x) инъективна и сюрьективна.

%\item Парадокс Жирара. Известно, что если слишком серьёзно расширить теорию, то она станет неразрешимой.
%
%Рассмотрим новый сорт для родов, $\triangle$, примем $S = \{\star, \square, \triangle\}$.
%Рассмотрим исчисление $U$, построенное аналогично типовым системам из лямбда-куба, с двумя аксиомами
%($\star : \square$ и $\square : \triangle$) и пятью парами правил ($(\star,\star), (\square,\star),
%(\square,\square), (\triangle,\star), (\triangle,\square)$).
%\begin{enumerate}
%\end{enumerate}

\section*{Домашнее задание №8: <<Язык Аренд>>}
\begin{enumerate}
\item Равенство.
\begin{enumerate}
\item Докажите, что $\texttt{left}=\texttt{right}$
\item Докажите, что если $a,b : \texttt{Nat}$ и $a = b$, то $\neg (a \ne b)$
\item Докажите, что если $a,b : \texttt{Nat}$, то $a = b \vee a \ne b$
\end{enumerate} 

\item Определим отношение <<меньше>> на натуральных числах так:
\begin{verbatim}
\data NatLess (a b : Nat) \with
  | 0, suc m => natless_less
  | suc m, suc n => natless_next (NatLess m n)
\end{verbatim}

Данный тип изоморфен утверждению $a < b$. Например, утверждение $1 < 3$ доказывается так:
\verb!\func zerolesszero : NatLess 1 3 => natless_next (natless_less)!

Докажите (везде предполагается, что $a,b,c : \texttt{Nat}$, если не указано иного):
\begin{enumerate}
\item $a < a + b + 1$; то есть, определите функцию\\\verb!\func n_less_sum (a b : Nat) : NatLess a (a Nat.+ suc b)!
\item Если $a < b$, то $a + c < b + c$
\item Если $a < b$ и $c < d$, то $a \cdot c < b \cdot d$
\item $a < 2^a$
\item Транзитивность: если $a < b$ и $b < c$, то $a < c$
\item Определите аналогичное отношение <<меньше или равно>> и докажите его антисимметричность
\item Если $a \ne b$, то $a < b \vee b < a$
\item Докажите, что $a < b$ тогда и только тогда, когда \verb!a < b! в смысле стандартных определений Аренда.
\end{enumerate}

\item Аналогично предыдущему упражнению, определите тип данных \verb!Even!
(<<чётное натуральное число>>) и докажите следующие утверждения:
\begin{enumerate}
\item Если $n$ --- чётное, то $\exists x.x + x = n$
\item Если $n$ таково, что $\exists x.x+x = n$, то $n$ --- чётное
\item Если $\exists x.x + x + 1 = n$, то неверно, что $n$ --- чётное
\end{enumerate}

\item Определите отношение (тип) <<делится нацело>> и докажите:
\begin{enumerate}
\item Рефлексивность, транзитивность и антисимметричность отношения
\item $a \cdot b$ делится нацело на $a$ и на $b$
\item Если $a$ делится нацело на $b$, то $\exists t.a = b \cdot t$
\item Если $\exists t.a = b * t$, то $a$ делится нацело на $b$
\item Если $a < b$, то невозможно, чтобы $a$ делилось нацело на $b$
\end{enumerate}

\end{enumerate}

\section*{Домашнее задание №9: <<Ещё доказательства>>}
\begin{enumerate}
\item Докажите недостающее свойство транзитивности \verb!prove-transitive!:

\begin{verbatim}
\record Integer-carrier {
    | pos : Nat
    | neg : Nat
}

\func integer-eq-relation (x y : Integer-carrier) : \Type =>
    x.neg Nat.+ y.pos = x.pos Nat.+ y.neg

\func prove-transitive (x y z : Integer-carrier) 
    (r1 : integer-eq-relation x y) (r2 : integer-eq-relation y z) :
    integer-eq-relation x z => {?}
\end{verbatim}

\item Как уже упоминалось, $\Pi$-типы соответствуют кванторам всеобщности,
а $\Sigma$-типы --- кванторам существования.

Как известно, доказательством квантора всеобщности является функция; докажем
$\forall x^\texttt{Int}.x=x$:

\verb!\func proof1 : \Pi (x : Int) -> x = x => \lam x => idp!

А доказательством квантора существования является пара из примера и доказательства
его соответствия условию; докажем, что
$\forall x.\exists y.y = x^2$:

\verb!\func proof2 : \Pi (x : Int) -> \Sigma (y : Int) (y = x * x) => \lam x => (x * x, idp)! 

Если мы доказываем утверждение, используя доказательство квантора существования,
мы можем сослаться на его составные части (на пример и доказательство соответствия примера утверждению).
Ниже $p$ --- это доказательство $\exists x^\texttt{Nat}.x^2=77$, тогда 
$p.1$ --- это пример значения, а $p.2$ --- доказательство утверждения
$(p.1)^2 = 77$:

\begin{verbatim}
\func proof3 : (\Sigma (x : Nat) (x Nat.* x = 77)) -> (\Sigma (x : Nat) (77 = x Nat.* x)) =>
  \lam p => (p.1, Paths.inv p.2)
\end{verbatim}

Обратим внимание, что пара, доказывающая существование --- <<зависимая>>: второй элемент пары 
доказывает утверждение с уже подставленным первым аргументом:

\begin{verbatim}
\func five_eq_five : 5 = 5 => idp {Nat} {5}
\func proof4 : \Sigma (x : Nat) (x = 5) => (5, five_eq_five)
\end{verbatim}

Проверьте, какие из следующих утверждений доказуемы (и тогда постройте
соответствующее доказательство), а какие нет (и тогда опровергните их, тоже на Аренде): 

\begin{enumerate}
\item $(\exists x.\exists y.\phi) \rightarrow (\exists y.\exists x.\phi)$ и
$(\forall x.\forall y.\phi) \rightarrow (\forall y.\forall x.\phi)$
\item $(\forall x.\exists y.\phi) \rightarrow (\exists y.\forall x.\phi)$  и наоборот,
$(\exists y.\forall x.\phi) \rightarrow (\forall x.\exists y.\phi)$
\item $(\neg\forall x.\phi) \rightarrow (\exists x.\neg \phi)$ и в обратную сторону.
\end{enumerate}

\item Вспомним одну из формулировок аксиомы выбора: если задано семейство
непустых подмножеств $\{B_a\}_{a \in A}$, 
то существует функция $f: A \rightarrow B$, что $\forall a. a \in A \rightarrow f (a) \in B_a$.

Давайте представим семейство $B_a$ отношением $Q \subseteq A \times B$, 
сопоставляющим элементу $a \in A$ множество $\{ b \in B\ |\ \langle a,b \rangle \in Q\}$.
Тогда налагаемое на функцию $f$ условие становится таким:
$$\forall a.a \in A \rightarrow \langle a, f (a) \rangle \in Q$$
что при трактовке множеств как типов приводит к следующей <<наивной аксиоме выбора>>:

\begin{verbatim}
\func naiveChoiceAxiom (A B : \Type) (Q : A -> B -> \Type)
                       (allInhabited : \Pi (a : A) -> \Sigma (b : B) (Q a b))
  : \Sigma (f : A -> B) (\Pi (a : A) -> Q a (f a))
\end{verbatim}

Докажите эту <<аксиому>>.

\item Двоичное дерево

\begin{verbatim}
\data Tree
  | node Tree Tree
  | leaf

\func leafs (t : Tree) : Nat \elim t
  | leaf => 1
  | node l r => leafs l + leafs r
\end{verbatim}

\begin{enumerate}
\item Докажите, что в полном двоичном дереве глубины $n$ всего $2^n$ листьев. 
\item Докажите, что всего два дерева имеют в точности 3 листа; при этом давайте
понимать множества как списки (из стандартной библиотеки). То есть, существует
список из двух деревьев, что: (а) любое дерево из списка имеет 3 листа; (б)
любое дерево с 3 листами принадлежит списку; (в) все элементы списка различны.
\item Найдите, сколько деревьев имеет глубину $\le 3$ --- и докажите соответствующее утверждение.
\item Найдите, сколько деревьев имеет глубину $\le n$ --- и докажите соответствующее утверждение.
\end{enumerate}

\end{enumerate}

\end{document}
